<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Magic of Closures in JavaScript – Interactive Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f7f6fa;
            margin: 30px;
        }

        .section {
            background: #fff;
            border: 1px solid #ccd;
            border-radius: 10px;
            margin-bottom: 28px;
            padding: 22px;
        }

        h2 {
            color: #1976d2;
        }

        .explain {
            background: #fffde7;
            border-left: 4px solid #fbc02d;
            padding: 9px;
            margin: 7px 0 13px 0;
        }

        .result {
            background: #e8f5e9;
            border-left: 4px solid #43a047;
            padding: 8px;
            margin-top: 8px;
        }

        button {
            padding: 9px 20px;
            font-size: 15px;
            border-radius: 6px;
            border: none;
            color: #fff;
            background: #1976d2;
            cursor: pointer;
            margin-top: 10px;
        }

        pre {
            background: #e3f2fd;
            padding: 7px;
            border-radius: 4px;
            font-size: 15px;
        }

        .tip {
            color: #c62828;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h1>JavaScript Closures: Powerful, Private, and Practical</h1>
    <div class="tip">Open your browser console to see the results in action!</div>

    <!-- Analogy explanation -->
    <div class="section">
        <h2>Closure Analogy: The Magic Box</h2>
        <div class="explain">
            Imagine you have a <b>magic box</b>. This box can remember secrets you put inside, even if you walk away.
            Every time you ask the box for a secret, it remembers what you put inside — nobody else can open it unless
            you hand them the box. <br><br>
            In JS, the <span class="highlight">magic box</span> is a function and the <span
                class="highlight">secret</span> is a variable inside that function. If you create another function
            inside the first function, the inner function keeps a secret connection to the box!
        </div>
    </div>

    <!-- Basic closure counter -->
    <div class="section">
        <h2>1. Making a Private Counter – Your Secret Notebook</h2>
        <div class="explain">
            You keep a <b>private notebook</b> inside a function, counting only for each visitor. Only your helper (the
            inner function) can update the number — no one can access the count directly!
        </div>
        <pre><code>
function makeCounter() {
  let count = 0;           // Secret notebook (private)
  return function() {
    count++;               // Only this helper updates the notebook
    console.log("Counter:", count);
  };
}
const myCounter = makeCounter();
myCounter(); // Counter: 1
myCounter(); // Counter: 2
myCounter(); // Counter: 3
    </code></pre>
        <button
            onclick="(function(){ function makeCounter(){ let count=0; return function(){ count++; console.log('Counter:',count); }; } const myCounter=makeCounter(); myCounter(); myCounter(); myCounter(); const myCounter2=makeCounter(); myCounter2(); myCounter(); myCounter2(); myCounter2(); alert('Check the console: the inner function tracks a private count!'); })()">
            Run Counter Example
        </button>
        <div class="result">Count is private; only <code>myCounter</code> can change it. Try calling again: the secret
            notebook keeps counting!</div>
    </div>

    <!-- Multiple closures keep their state separately -->
    <div class="section">
        <h2>2. Each Magic Box Remembers Its Own Secrets</h2>
        <div class="explain">
            Every time you make a new box, it keeps its own secrets, like each person having their own private notebook.
        </div>
        <pre><code>
const boxA = makeCounter(); // Each gets its own notebook
const boxB = makeCounter();
boxA(); // Counter: 1
boxA(); // Counter: 2
boxB(); // Counter: 1 (starts fresh)
boxA(); // Counter: 3
    </code></pre>
        <button
            onclick="(function(){ function makeCounter(){ let count=0; return function(){ count++; console.log('Counter:',count); }; } const boxA=makeCounter(); const boxB=makeCounter(); boxA(); boxA(); boxB(); boxA(); alert('Console: boxA and boxB count separately!'); })()">
            Run Multiple Counters
        </button>
        <div class="result"><code>boxA</code> and <code>boxB</code> keep their own private counts.</div>
    </div>

    <!-- Private helper function -->
    <div class="section">
        <h2>3. True Privacy: Only the Helper Knows the Secret</h2>
        <div class="explain">
            The "secret notebook" can't be read directly — only the helper sees the secret.
        </div>
        <pre><code>
const secretBox = makeCounter();
console.log(secretBox.count); // undefined!
    </code></pre>
        <button
            onclick="(function(){ function makeCounter(){ let count=0; return function(){ count++; console.log('Counter:',count); }; } const secretBox=makeCounter(); console.log(secretBox.count); alert('Check console: No one can read secretBox.count directly!'); })()">
            Run Private Access Demo
        </button>
        <div class="result">Trying to read <code>count</code> outside shows <b>undefined</b> — it’s truly private!</div>
    </div>

    <!-- Stateful factory/closure -->
    <div class="section">
        <h2>4. Closure for Encapsulated Factories</h2>
        <div class="explain">
            Factories use closures to create stateful helpers — only the returned function can change the state.
            Example: magical dice!
        </div>
        <pre><code>
function makeDice(sides) {
  let rolls = []; // Encapsulated log
  return function roll() {
    let value = Math.ceil(Math.random() * sides);
    rolls.push(value);
    console.log("Rolled:", value, "Previous rolls:", rolls.join(", "));
  };
}
const d6 = makeDice(6);
d6(); d6(); d6();
    </code></pre>
        <button
            onclick="(function(){ function makeDice(sides){ let rolls=[]; return function(){ let value=Math.ceil(Math.random()*sides); rolls.push(value); console.log('Rolled:',value,'Previous rolls:',rolls.join(', ')); }; } const d6=makeDice(6); d6(); d6(); d6(); alert('Console: each dice keeps its own private roll log using closure.'); })()">
            Run Dice Example
        </button>
        <div class="result">Each dice keeps its own <b>history</b> inside — another use for closures!</div>
    </div>

    <!-- Higher-order/Function Decorator -->
    <div class="section">
        <h2>5. Closures for Function Decorators (Higher Order)</h2>
        <div class="explain">
            You can write functions that create <b>custom helpers</b> with attached state, making your code more
            modular.
        </div>
        <pre><code>
function makeMultiplier(x) {
  return function(y) {
    return x * y; // Remembers x (closure!)
  };
}
const double = makeMultiplier(2);
console.log(double(5)); // 10
const triple = makeMultiplier(3);
console.log(triple(7)); // 21
    </code></pre>
        <button
            onclick="(function(){ function makeMultiplier(x){ return function(y){console.log('Result:',x*y);}; } const double=makeMultiplier(2); double(5); const triple=makeMultiplier(3); triple(7); alert('Console: function remembers multiplier x — closure in action.'); })()">
            Run Multiplier Example
        </button>
        <div class="result">Closures can “attach” custom state to helper functions. Powerful!</div>
    </div>

    <div class="tip">Edit and play with the code blocks above to really master closures!</div>
</body>

</html>